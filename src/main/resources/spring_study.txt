SRP, 단일 책임 원칙 - 한 클래스는 하나의 책임만 가져야 한다.
구현 객체를 생성, 연결하는 책임 - AppConfig
클라이언트 객체는 실행만 함

DIP 의존관계 역전 원칙 - 추상화에 의존 O, 구체화에 의존 X
AppConfig 를 통해 의존관계 주입을 통해 기존에 추상화 인터페이스에만 의존하는 줄 알았지만,
구체 클래스에도 의존 하고있었던 코드를 해결함

OCP - 소프트웨어 요소는 확장에는 열려 있지만, 변경에는 닫혀 있어야 한다.
애플리케이션을 사용영역, 구성영역으로 나누어서 작동시킴 (이도 의존관계 주입을 통해서 사용영역의 변경을 막음)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
스프링의 기본 개념

IOC - 제어의 역전
기존에는 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행 했다.
구현 객체가 프로그램의 제어 흐름을 스스로 조종했다는 뜻, 이는 개발자 입장에서 매우 자연스러움

AppConfig를 만든 후로는 구현 객체는 자신의 로직을 실행하는 역할만을 한다.
AppConfig가 제어 흐름을 모두 가져가는 것이다.

이처럼 프로그램의 제어 흐름을 내부(구현객체)에서 직접 제어하는게 아니라
외부에서(AppConfig) 제어하는 것을 IOC, 제어의 역전이라고 한다.

DI - 의존관계 주입
구현 객체에서는 실제로는 어떤 구현 객체가 사용될지는 모른다.
정적인 클래스 의존 관계, 동적인 객체 의존 관계를 분리해서 생각해야 한다.
동적인 그림만 바꿀 분, 정적인 클래스 다이어그램은 손대지 않는다.(애플리케이션 객체를 변경하지 않는다는 뜻

컨테이너
IOC 컨테이너, DI 컨테이너
AppConfig(어셈블러, 오브젝트 컨트롤러 등의 이름으로도 불림)처럼 객체를 생성하고 관리하면서
의존관계를 연결해 주는 것을 IOC 컨테이너 또는 DI 컨테이너라고 한다.

프레임워크, 라이브러리
내가 작성한 코드를 프레임워크가 제어, 실행하면 그것은 프레임워크디.
내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
자동 의존관계 주입
편리한 자동 기능들을 기본으로 사용하자! (업무로직에서는 문제가 발생해도 찾기 쉽기에 자동을 적극 활용)

수동 빈 등록은???
(기술지원 로직은 문제가 발생하면 찾기가 힘들고, 양이 업무로직 보다는 적기에 수동을 활용하는 것도 좋다.)
다형성을 적극 활용하는 비즈니스 로직(인터페이스 안에 어떤 구현체들이 있는지 일일이 파악하기 힘든 경우 등)은 수동 등록을 고민해보자
