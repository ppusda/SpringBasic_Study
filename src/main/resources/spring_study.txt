SRP, 단일 책임 원칙 - 한 클래스는 하나의 책임만 가져야 한다.
구현 객체를 생성, 연결하는 책임 - AppConfig
클라이언트 객체는 실행만 함

DIP 의존관계 역전 원칙 - 추상화에 의존 O, 구체화에 의존 X
AppConfig 를 통해 의존관계 주입을 통해 기존에 추상화 인터페이스에만 의존하는 줄 알았지만,
구체 클래스에도 의존 하고있었던 코드를 해결함

OCP - 소프트웨어 요소는 확장에는 열려 있지만, 변경에는 닫혀 있어야 한다.
애플리케이션을 사용영역, 구성영역으로 나누어서 작동시킴 (이도 의존관계 주입을 통해서 사용영역의 변경을 막음)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
스프링의 기본 개념

IOC - 제어의 역전
기존에는 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행 했다.
구현 객체가 프로그램의 제어 흐름을 스스로 조종했다는 뜻, 이는 개발자 입장에서 매우 자연스러움

AppConfig를 만든 후로는 구현 객체는 자신의 로직을 실행하는 역할만을 한다.
AppConfig가 제어 흐름을 모두 가져가는 것이다.

이처럼 프로그램의 제어 흐름을 내부(구현객체)에서 직접 제어하는게 아니라
외부에서(AppConfig) 제어하는 것을 IOC, 제어의 역전이라고 한다.

DI - 의존관계 주입
구현 객체에서는 실제로는 어떤 구현 객체가 사용될지는 모른다.
정적인 클래스 의존 관계, 동적인 객체 의존 관계를 분리해서 생각해야 한다.
동적인 그림만 바꿀 분, 정적인 클래스 다이어그램은 손대지 않는다.(애플리케이션 객체를 변경하지 않는다는 뜻

컨테이너
IOC 컨테이너, DI 컨테이너
AppConfig(어셈블러, 오브젝트 컨트롤러 등의 이름으로도 불림)처럼 객체를 생성하고 관리하면서
의존관계를 연결해 주는 것을 IOC 컨테이너 또는 DI 컨테이너라고 한다.

프레임워크, 라이브러리
내가 작성한 코드를 프레임워크가 제어, 실행하면 그것은 프레임워크디.
내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
자동 의존관계 주입
편리한 자동 기능들을 기본으로 사용하자! (업무로직에서는 문제가 발생해도 찾기 쉽기에 자동을 적극 활용)

수동 빈 등록은???
(기술지원 로직은 문제가 발생하면 찾기가 힘들고, 양이 업무로직 보다는 적기에 수동을 활용하는 것도 좋다.)
다형성을 적극 활용하는 비즈니스 로직(인터페이스 안에 어떤 구현체들이 있는지 일일이 파악하기 힘든 경우 등)은 수동 등록을 고민해보자

////////////////////////////////////////////////////////////////////////////////

스프링 빈의 라이프 사이클 -> 객체 생성, 의존 관계 주입 (이 과정이 끝나야만 데이터를 사용할 수 있는 준비가 된다.)

=== 초기화는 의존관계 주입이 모두 완료되고 난 후 호출해야한다.
=> 콜백 메서드를 통해서 알 수 있음 (그렇기에 안전하게 종료 작업을 할 수 있다.)

스프링 빈의 이벤트 라이프 사이클
-> 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용
-> 소멸 전 콜백 -> 스프링 종료 (싱글톤의 경우 이런식)

*** 객체의 생성과 초기화를 분리하자 (생성자 내에서 무거운 작업을 하지말자 ex_외부연결, 활용 등)
=> 유지보수 측면에서 좋다...

빈 생명주기 콜백들 ->
인터페이스 (initializingBean, DisposableBean)
설정 정보에 초기화 메서드, 종료메서드 지원
어노테이션 (@PostConstruct, @PreDestroy)

////////////////////////////////////////////////////////////////////////////////

빈 스코프 - 빈이 존재할 수 있는 범위

 *** 싱글톤 - 스프링 컨테이너는 기본적으로 싱글톤으로 생성한다, 시작부터 종료까지 유지되는 가장 넓은 범위의 스코프
*** 프로토타입 - 스프링 컨테이너는 생성과 의존관계 주입, 초기화까지만 처리하고 더는 관리하지 않는 매우 짧은 범위의 스코프
               싱글톤과는 반대로 항상 새로운 인스턴스를 생성해서 반환한다.

웹 관련 스코프
 *** request : 웹 요청이 들어오고 나갈 때 까지 유지되는 스코프
session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
application : 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

////////////////////////////////////////////////////////////////////////////////
Dependency Lookup
말그대로 의존관계를 찾아가는 기능이다.
Singleton과 Prototype을 함께 사용할 때 문제가 생길 수 있는데,

Spring의 ObjectFactory, ObjectProvider (Spring에 의존적이지만, 편의기능이 많고 별도의 라이브러리가 필요없음)
javax.inejct의 Provider (별도의 라이브러리가 필요하지만 자바표준이름로 다른 컨테이너에서도 사용가능)
를 사용해서 이 문제를 해결할 수 있다.

싱글톤과 프로토타입 빈을 같이 사용할 상황 자체가 그렇게 많지 않을 수 있겠지만,
DL이 필요한 상황이라면 언제라도 쓸 수 있으니 알아두어야 할 것이다.
(순환참조 등)

////////////////////////////////////////////////////////////////////////////////

스프링을 사용하다 보면 이 기능 뿐만 아니라 다른 기능들도 자바 표준과 스프링이 제공하는 기능이 겹칠 때가 있는데,
대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면,
스프링이 제공하는 기능을 사용하면된다.

////////////////////////////////////////////////////////////////////////////////

